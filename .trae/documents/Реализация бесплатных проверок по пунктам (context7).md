## Архитектура и Поток

* Бэкенд: расширяем `audit_requests` для хранения прогресса и результатов по шагам (`progress: 0–100`, `checks: JSONB`, `status`).

* Оркестратор: последовательный запуск 4 проверок; после каждого шага — запись прогресса и результата в БД; итоговый расчет `risk_level`, генерация краткого `summary`.

* API: `POST /api/start-audit` запускает оркестратор асинхронно; `GET /api/get-report-status?id=...` возвращает `status`, `progress`, `checks[]`, `riskLevel`, `summary`.

* Фронтенд: форма бесплатной проверки в `HeroSection` показывает прогресс-бар и статусы шагов в режиме polling.

## Контекст (audit)

* Новый модуль `lib/audit.ts`: единая точка подготовки данных для проверок.

* Содержит: `url`, `origin`, HTML главной страницы, список ссылок, формы (method, action, inputs, defaultChecked), утилиты `fetchHtml(path)`, `resolveUrl`, `parseForms(html)`.

* Реиспользуется всеми сервисами; минимизирует дублирование и сетевые запросы.

## Сервисы Проверок (отдельные функции)

* `checkPrivacyPolicyPresence(ctx)`: поиск ссылки на политику конфиденциальности в HTML (тексты: “Политика конфиденциальности”, пути `/privacy`, `/privacy-policy`), проверка доступности (HTTP 200) без авторизации.

* `checkConsentCheckboxes(ctx)`: анализ форм сбора данных (обратная связь, подписка, регистрация, заказ): наличие явных чекбоксов согласия; отказ от предустановленных галочек (`defaultChecked=false`).

* `checkHttpsForms(ctx)`: подтверждение, что сайт доступен по `https`; все `form.action` на отправку данных не используют `http://` (относительные пути допустимы при https-оригине).

* `checkCookieBanner(ctx)`: наличие баннера/плашки (по ключевым словам: “cookie”, “cookies”, “файлы cookie”, “куки”, `class*="cookie"`, `id*="cookie"`).

## Технологии и Зависимости

* HTTP-запросы: `axios` (уже в проекте).

* Парсинг HTML: по умолчанию лёгкие эвристики/регексы; опционально добавим `cheerio` для более точного парсинга (по согласованию).

* Типы результатов: `CheckId`, `CheckStatus ('pass'|'fail'|'unknown')`, `CheckResult { id, status, details, evidence }`.

## Реализация Оркестратора

* Файл `lib/freeAuditRunner.ts`:

  * Загружает `audit`, последовательно вызывает 4 проверки.

  * После каждого шага: `progress=25/50/75/100`, апдейт `audit_requests.checks[]`.

  * Рассчитывает `risk_level` (например, `high` при ≥2 fail, `medium` при 1 fail, иначе `low`).

  * Заполняет `violations` агрегированными пунктами (для совместимости с текущим UI), либо остаётся в `checks`.

## Расширения API

* `app/api/start-audit/route.ts`: вместо таймера — запуск `freeAuditRunner` (асинхронно, без блокировки запроса).

* `app/api/get-report-status/route.ts`: включает `progress` и `checks[]` в ответ; `summary` формируется из статусов проверок.

## Обновления UI

* `HeroSection`: прогресс-бар, список шагов с текущим статусом; продолжает опрашивать `get-report-status` каждые 2s.

* Статусы: «Выполняется», «Пройдено», «Не пройдено», «Не определено».

## Миграции БД

* Добавить поля в `audit_requests`: `progress INTEGER DEFAULT 0`, `checks JSONB DEFAULT '[]'`, `status VARCHAR DEFAULT 'pending'` (если поля уже есть — расширяем только `progress` и `checks`).

* Без изменения `violations`/`risk_level`.

## Валидация и Тесты

* Юнит‑тесты для каждой функции проверки на фикстурах HTML.

* Нагрузочные тесты: на 3–5 реальных доменах.

* Вручную: проверить прогресс/статусы на фронтенде; убедиться в корректности эвристик.

## Порядок Работ

1. Создать `lib/audit.ts` и утилиты парсинга.
2. Реализовать 4 функции проверок.
3. Добавить `lib/freeAuditRunner.ts` и интегрировать в `start-audit`.
4. Расширить `get-report-status` и миграции.
5. Добавить UI прогресс и статусы в `HeroSection`.
6. Написать тесты и провести верификацию.

## Примечание по audit

* В кодовой базе упоминаний «`audit`» нет; создадим модуль `lib/audit.ts` как основу контекстного слоя с соответствующим именованием, чтобы соответствовать вашему требованию «use `audit`».

